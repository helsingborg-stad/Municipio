<?php 

namespace Municipio\Helper;

use Municipio\Helper\CacheBust;
use WpService\WpService;
use Municipio\Helper\EnqueueTranslation;

/**
 * Provides helpers to enqueue scripts and styles with optional module and localization support.
 */
class Enqueue {

    public function __construct(private WpService $wpService){}

    private const ASSETS_DIST_PATH = '/assets/dist/';

    /**
     * Enqueue a script or style with optional module type and localization.
     *
     * @param string $handle The handle name for the script or style.
     * @param string $src The source URL of the script or style.
     * @param array $deps An array of dependencies for the script or style.
     * @param array $localize Optional localization data with keys 'object_name' and 'data'.
     * @param bool  $module  Whether to add the "module" attribute to the script tag. 
     *                       If null, module equals true if js extension was found and 
     *                       if it was resolved in manifest.json (assumed generated by vite).
     * @return void
     * @throws \InvalidArgumentException If localization data is invalid.
     */
    public function add(string $handle, string $src, array $deps = [], ?EnqueueTranslation $localize = null, ?bool $module = null) {

        if(empty($handle)) {
          throw new \InvalidArgumentException("Handle cannot be empty");
        }

        if(empty($src)) {
          throw new \InvalidArgumentException("Source cannot be empty for handle: {$handle}");
        }

        $func     = $this->getRegisterEnqeueFunctions($this->getFileType($src, $handle));
        $module   = $module ?? $this->isModule($src, $handle);
        $fullSrc  = $this->getAssetUrl($src);

        $func['register']($handle, $fullSrc, $deps);

        if (is_a($localize, EnqueueTranslation::class)) {
          $func['localize']($handle, $localize->getObjectName(), $localize->getTranslations());
        }

        if ($module === true) {
          $this->addAttributesToScriptTag($handle, ['type' => 'module']);
        }

        $func['enqueue']($handle);
    }

    /**
     * Get the register, enqueue, and optional localize functions based on file type.
     *
     * @param string $type The file type (e.g. 'js' or 'css').
     * @return array Associative array with keys 'register', 'enqueue', and optionally 'localize' containing callable functions.
     * @throws \InvalidArgumentException If an invalid type is provided.
     */
    private function getRegisterEnqeueFunctions($type) {
        if ($type === 'js') {
            return [
                'register'  => fn($handle, $src, $deps) => $this->wpService->wpRegisterScript($handle, $src, $deps, false, true),
                'enqueue'   => fn($handle) => $this->wpService->wpEnqueueScript($handle),
                'localize'  => fn($handle, $object_name, $data) => $this->wpService->wpLocalizeScript($handle, $object_name, $data)
            ];
        }

        if ($type === 'css') {
            return [
                'register'  => fn($handle, $src, $deps) => $this->wpService->wpRegisterStyle($handle, $src, $deps, false),
                'enqueue'   => fn($handle) => $this->wpService->wpEnqueueStyle($handle)
            ];
        }

        throw new \InvalidArgumentException('Invalid type provided. Use "js" or "css".');
    }

    /**
     * Add attributes to the script tag for a given handle.
     *
     * @param string $handle The handle of the script to modify.
     * @param array $attributes Key-value pairs of attributes to add to the script tag.
     * @return void
     */
    private function addAttributesToScriptTag(string $handle, array $attributes): void {
        $this->wpService->addFilter('script_loader_tag', function($tag, $tag_handle) use ($handle, $attributes) {
            if ($tag_handle === $handle) {
                foreach ($attributes as $key => $value) {
                    $tag = str_replace(' src=', sprintf(' %s="%s" src=', esc_attr($key), esc_attr($value)), $tag);
                }
            }
            return $tag;
        }, 10, 2);
    }

    /**
     * Get the file type extension from the source string.
     *
     * @param string $src The source file path or URL.
     * @return string The file extension (e.g. 'js' or 'css').
     * @throws \InvalidArgumentException If the file extension is unsupported.
     */
    private function getFileType(string $src, string $handle = ""): string {
      
        $ext = strtolower(pathinfo($src, PATHINFO_EXTENSION) ?? '');

        if(empty($ext)) {
            throw new \InvalidArgumentException("Could not determine file extension from source: {$src} using handle: {$handle}");
        }

        if (!in_array($ext, ['js', 'css'], true)) {
            throw new \InvalidArgumentException("Unsupported file extension: {$ext}");
        }
        return $ext;
    }

    /**
     * Get the URL of an asset with cache busting.
     *
     * @param string $file The file name to get the URL for.
     * @return string The URL of the asset.
     */
    private function getAssetUrl(string $src): string {
        return $this->wpService->getTemplateDirectoryUri() .
            self::ASSETS_DIST_PATH .
            CacheBust::name($src);
    }

    /**
     * Determine if the script should be treated as a module based on its source.
     *
     * @param string $src The source file path or URL.
     * @return bool True if the script should be treated as a module, false otherwise.
     */
    private function isModule(string $src, string $handle = ""): bool {
        $ext = $this->getFileType($src, $handle);
        if ($ext === 'js') {
            $manifest = CacheBust::getManifest();
            return isset($manifest[$src]);
        }
        return false;
    }
}